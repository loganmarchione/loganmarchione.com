<!-- Claude wrote this ü§∑ -->
 
<!-- Variables -->
{{ $version := .Get "version" | default "0.158.0" }}
{{ $id := .Get "id" | default "default" }}
{{ $stl := .Get "stl" }}
{{ $width := .Get "width" | default "500" }}
{{ $height := .Get "height" | default "500" }}
{{ $background := .Get "background" | default "#f0f0f0" }}
{{ $color := .Get "color" | default "#0077be" }}
{{ $center := .Get "center" | default "true" }}
{{ $rotateX := .Get "rotateX" | default "0" }}
{{ $rotateY := .Get "rotateY" | default "0" }}
{{ $rotateZ := .Get "rotateZ" | default "0" }}

<!-- Create a container for rendering the scene -->
<div id="threejs-container-{{ $id }}" style="width: {{ $width }}px; height: {{ $height }}px; border: 1px solid #ccc; margin: 20px 0;"></div>

<!-- Import Three.js -->
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@{{ $version }}/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@{{ $version }}/examples/jsm/"
    }
  }
</script>

<!-- Three.js STL Viewer Script -->
<script type="module">
import * as THREE from 'three';
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Get the container
const container = document.getElementById('threejs-container-{{ $id }}');
const width = {{ $width }};
const height = {{ $height }};

// Check for WebGL support
function isWebGLAvailable() {
    try {
        const canvas = document.createElement('canvas');
        return !!(window.WebGLRenderingContext && 
                 (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
    } catch(e) {
        return false;
    }
}

// Show error message if WebGL is not available
if (!isWebGLAvailable()) {
    container.innerHTML = `
        <div style="
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            height: 100%; 
            color: #666; 
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        ">
            <div style="font-size: 18px; margin-bottom: 10px; color: #d32f2f;">‚ö†Ô∏è WebGL Not Available</div>
            <div style="font-size: 14px; line-height: 1.4;">
                This 3D viewer requires WebGL to display STL files.<br>
                Please enable WebGL in your browser settings or try a different browser.
            </div>
        </div>
    `;
    throw new Error('WebGL not available');
}

// Create scene
const scene = new THREE.Scene();
// Handle colors - truncate to 6 chars if longer (remove alpha channel)
const backgroundColor = '{{ $background }}'.length > 7 ? '{{ $background }}'.substring(0, 7) : '{{ $background }}';
console.log('Background color:', backgroundColor);
scene.background = new THREE.Color(backgroundColor);

// Create camera
const camera = new THREE.PerspectiveCamera(75, width / height, 0.01, 10000);

// Create renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(width, height);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
container.appendChild(renderer.domElement);

// Add lights
const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(1, 1, 1);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
scene.add(directionalLight);

// Add orbit controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Load STL file
const loader = new STLLoader();
loader.load('{{ $stl }}', function (geometry) {
    // Conditionally center the geometry based on parameter
    {{ if eq $center "true" }}
    geometry.center();
    {{ end }}
    
    // Compute bounding box for camera positioning
    geometry.computeBoundingBox();
    const box = geometry.boundingBox;
    const size = box.getSize(new THREE.Vector3()).length();
    const center = box.getCenter(new THREE.Vector3());
    
    // Create material
    // Handle colors - truncate to 6 chars if longer (remove alpha channel)
    const objectColor = '{{ $color }}'.length > 7 ? '{{ $color }}'.substring(0, 7) : '{{ $color }}';
    console.log('Object color:', objectColor);
    const material = new THREE.MeshPhongMaterial({ 
        color: objectColor,
        shininess: 100,
        side: THREE.DoubleSide
    });
    
    // Create mesh
    const mesh = new THREE.Mesh(geometry, material);
    
    // Apply any rotation specified in parameters
    mesh.rotation.x = {{ $rotateX }} * Math.PI / 180; // Convert degrees to radians
    mesh.rotation.y = {{ $rotateY }} * Math.PI / 180;
    mesh.rotation.z = {{ $rotateZ }} * Math.PI / 180;
    
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    
    // Position camera - start further back to avoid clipping
    camera.position.copy(center);
    camera.position.x += size * 1.5;
    camera.position.y += size * 0.5;
    camera.position.z += size * 1.5;
    camera.lookAt(center);
    
    // Update camera planes based on object size
    camera.near = size * 0.01;
    camera.far = size * 10;
    camera.updateProjectionMatrix();
    
    // Update controls
    controls.target.copy(center);
    controls.update();
    
}, function (progress) {
    // Loading progress
    console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
}, function (error) {
    console.error('Error loading STL:', error);
    // Add error message to container
    container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-family: Arial, sans-serif;">Error loading STL file</div>';
});

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}
animate();

// Handle window resize
function onWindowResize() {
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
}
window.addEventListener('resize', onWindowResize);
</script>